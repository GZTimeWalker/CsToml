using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace CsToml.Generator;

[Generator(LanguageNames.CSharp)]
public partial class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("TomlSerializedObjectGenerator.cs", """
using System;
using System.Diagnostics.CodeAnalysis;

namespace CsToml;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class TomlSerializedObjectAttribute : Attribute
{
    public TomlNamingConvention NamingConvention { get; init; }

    public TomlSerializedObjectAttribute()
    {
        NamingConvention = TomlNamingConvention.None;
    }

    public TomlSerializedObjectAttribute(TomlNamingConvention namingConvention)
    {
        NamingConvention = namingConvention;
    }
}

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
internal sealed class TomlValueOnSerializedAttribute : Attribute
{
    public string? AliasName { get; }

    public TomlValueOnSerializedAttribute() {  }

    public TomlValueOnSerializedAttribute(string? aliasName) { this.AliasName = aliasName; }
}

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
internal sealed class TomlIgnoreAttribute : Attribute
{
    public TomlIgnoreCondition Condition { get; set; } = TomlIgnoreCondition.Never;

    public TomlIgnoreAttribute() {  }
}

""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "CsToml.TomlSerializedObjectAttribute",
            static (node, token) =>
            {
                return node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax;
            },
            static (context, token) => context).
            Combine(context.CompilationProvider).
            WithComparer(Comparer.Instance);

        context.RegisterSourceOutput(source, Emit);
    }

    private void Emit(SourceProductionContext context, (GeneratorAttributeSyntaxContext, Compilation) source)
    {
        var syntaxContext = source.Item1;
        var symbol = (INamedTypeSymbol)syntaxContext.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)syntaxContext.TargetNode;

        var typeMeta = new TypeMeta(symbol, typeNode);
        var constructorMeta = new ConstructorMeta(symbol, typeNode, typeMeta);

        if (!(typeMeta.Validate(context) && constructorMeta.Validate(context)))
            return;

        // '<' and '>' are not allowed in file names.
        var replaceTypeName = typeMeta.TypeName.Replace("<", "_").Replace(">", "_").Replace(",", "_").Replace(" ", "");

        context.AddSource($"{replaceTypeName}_generated.g.cs", Generate(typeMeta, constructorMeta));
    }

    private string Generate(TypeMeta typeMeta, ConstructorMeta constructorMeta)
    {
        // Check if it belongs to the global namespace.
        var namespaceTag = string.IsNullOrWhiteSpace(typeMeta.NameSpace) ? string.Empty : $"namespace {typeMeta.NameSpace};";

        var code = $$"""
// <auto-generated> This .cs file is generated by CsToml.Generator. </auto-generated>
#nullable enable
#pragma warning disable CS0219 // The variable 'variable' is assigned but its value is never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment.
#pragma warning disable CS8602 // Dereference of a possibly null reference.
#pragma warning disable CS8603 // Possible null reference return.
#pragma warning disable CS8604 // Possible null reference argument for parameter.
#pragma warning disable CS8619 // Possible null reference assignment fix.
#pragma warning disable CS8620 // Argument cannot be used for parameter due to differences in the nullability of reference types.

using CsToml;
using CsToml.Error;
using CsToml.Formatter;
using CsToml.Formatter.Resolver;

{{namespaceTag}}

partial {{typeMeta.TypeKeyword}} {{typeMeta.TypeName}} : ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>
{

    static {{typeMeta.GenericTypeParameterName}} ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>.Deserialize(ref TomlDocumentNode rootNode, CsTomlSerializerOptions options)
    {
{{GenerateDeserializePart(typeMeta, constructorMeta)}}    }

    static void ITomlSerializedObject<{{typeMeta.GenericTypeParameterName}}>.Serialize<TBufferWriter>(ref Utf8TomlDocumentWriter<TBufferWriter> writer, {{typeMeta.GenericTypeParameterName}} target, CsTomlSerializerOptions options)
    {
{{GenerateSerializePart(typeMeta)}}    }

    static void ITomlSerializedObjectRegister.Register()
    {
{{GenerateRegisterPart(typeMeta)}}
    }
}
""";

        return code;
    }

    private string GenerateDeserializePart(TypeMeta typeMeta, ConstructorMeta constructorMeta)
    {
        var builder = new StringBuilder();

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""
        if (!(rootNode.HasValue || rootNode.IsTableHeader)) return default;

""");
        }

        foreach (var member in typeMeta.Members)
        {
            var propertyName = member.DefinedName;
            var accessName = member.CanAliasName ? member.AliasName : propertyName;

            builder.AppendLine($$"""
        var __{{propertyName}}__RootNode = rootNode[{{$"@\"{accessName}\"u8"}}];
        var __{{propertyName}}__ = options.Resolver.GetFormatter<{{member.Symbol.Type.ToFullFormatString()}}>()!.Deserialize(ref __{{propertyName}}__RootNode, options);
""");
        }

        builder.AppendLine();

        if (constructorMeta.IsImplicitlyDeclared || constructorMeta.IsParameterlessOnly || (constructorMeta.ConstructorParameters.Length == 0 && constructorMeta.IncludeParameterless))
        {
            builder.AppendLine($"        var target = new {typeMeta.TypeName}(){{");
            foreach (var member in typeMeta.Members)
            {
                var propertyName = member.DefinedName;
                builder.AppendLine($"            {propertyName} = __{propertyName}__,");
            }
            builder.AppendLine($"        }};");
            builder.AppendLine();
            builder.AppendLine($"        return target;");
        }
        else
        {
            builder.Append($"        var target = new {typeMeta.TypeName}(");

            for (var i = 0; i < constructorMeta.ConstructorParameterProperties.Length; i++)
            {
                var p = constructorMeta.ConstructorParameterProperties[i];
                var propertyName = p.Name;
                builder.Append($"__{propertyName}__");
                if (i < constructorMeta.ConstructorParameters.Length - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append($")");

            if (constructorMeta.MembersOfObjectInitialisers.Length > 0)
            {
                builder.AppendLine($"{{");
                foreach (var property in constructorMeta.MembersOfObjectInitialisers)
                {
                    var propertyName = property.Name;
                    builder.AppendLine($"            {propertyName} = __{propertyName}__,");
                }
                builder.AppendLine($"        }};");
            }
            else
            {
                builder.AppendLine(";");
            }
            builder.AppendLine($"        return target;");

        }

        return builder.ToString();
    }

    private string GenerateSerializePart(TypeMeta typeMeta)
    {
        var builder = new StringBuilder();

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""
        if (target == null) ThrowIfNull(nameof(target));

""");
        }

        var members = typeMeta.Members;
        var onlyTomlSerializedObject = members.Length == 1 && members[0].SerializationKind == TomlSerializationKind.TomlSerializedObject;
        if (!onlyTomlSerializedObject)
        {
            builder.AppendLine("        writer.BeginScope();");
        }

        var memberCount = 0;
        foreach (var member in members)
        {
            memberCount++;

            var propertyName = member.DefinedName;
            var accessName = member.CanAliasName ? member.AliasName : propertyName;
            var kind = member.SerializationKind;
            var symbol = member.Symbol;
            var endKeyValue = memberCount == members.Length ? "true" : "";
            var fullTypeName = symbol.Type.ToFullFormatString();
            var ignoreCondition = member.IgnoreCondition; // 0 = Never, 1 = Always, 2 = WhenWritingNull

            // Skip if Always
            if (ignoreCondition == TomlIgnoreCondition.Always)
            {
                continue;
            }

            // Check if the property type is nullable (reference type or Nullable<T>)
            var isNullable = symbol.Type.NullableAnnotation == NullableAnnotation.Annotated
                || (symbol.Type is INamedTypeSymbol namedSymbol && namedSymbol.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T);

            // Generate null check wrapper if needed
            // Only Primitive and Object types need null check wrapping
            // For other types, the formatter handles null internally
            var needsNullCheck = isNullable && (ignoreCondition == TomlIgnoreCondition.WhenWritingNull || kind == TomlSerializationKind.Primitive || kind == TomlSerializationKind.Object);

            if (needsNullCheck)
            {
                // If Condition is WhenWritingNull, only check if value is not null
                // Otherwise, also check the global setting
                var condition = ignoreCondition == TomlIgnoreCondition.WhenWritingNull
                    ? $"target.{propertyName} != null"
                    : $"target.{propertyName} != null || (int)options.SerializeOptions.DefaultNullBehavior == 0";

                builder.AppendLine($$"""
        if ({{condition}})
        {
""");
            }

            var indent = needsNullCheck ? "    " : "";

            if (kind == TomlSerializationKind.Primitive || kind == TomlSerializationKind.Object)
            {
                builder.AppendLine($$"""
        {{indent}}writer.WriteKey({{$"@\"{accessName}\"u8"}});
        {{indent}}writer.WriteEqual();
        {{indent}}options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        {{indent}}writer.EndKeyValue({{endKeyValue}});
""");
            }
            else if (kind == TomlSerializationKind.TomlSerializedObject)
            {
                builder.AppendLine($$"""
        if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table)){
            writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
            writer.WriteNewLine();
            writer.BeginCurrentState(TomlValueState.Table);
            writer.PushKey({{$"@\"{accessName}\"u8"}});
            options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
            writer.PopKey();
            writer.EndCurrentState();
        }
        else
        {
            writer.PushKey({{$"@\"{accessName}\"u8"}});
            options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
            writer.PopKey();
        }
""");
            }
            else if (kind == TomlSerializationKind.Dictionary)
            {
                builder.AppendLine($$"""
        if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table)){
            writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
            writer.WriteNewLine();
            writer.BeginCurrentState(TomlValueState.Table);
            writer.PushKey({{$"@\"{accessName}\"u8"}});
            options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
            writer.PopKey();
            writer.EndCurrentState();
        }
        else
        {
            writer.WriteKey({{$"@\"{accessName}\"u8"}});
            writer.WriteEqual();
            writer.BeginCurrentState(TomlValueState.ArrayOfTable);
            options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
            writer.EndCurrentState();
            writer.EndKeyValue({{endKeyValue}});
        }
""");
            }
            else if (kind == TomlSerializationKind.ArrayOfITomlSerializedObject || kind == TomlSerializationKind.CollectionOfITomlSerializedObject)
            {
                builder.AppendLine($$"""
        writer.WriteKey({{$"@\"{accessName}\"u8"}});
        writer.WriteEqual();
        writer.BeginCurrentState(TomlValueState.ArrayOfTable);
        options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        writer.EndCurrentState();
        writer.EndKeyValue({{endKeyValue}});
""");
            }
            else if (kind == TomlSerializationKind.TypeParameter)
            {
                builder.AppendLine($$"""
        var __{{propertyName}}Formatter = options.Resolver.GetFormatter<{{fullTypeName}}>();
        if (__{{propertyName}}Formatter != null)
        {
            var __{{propertyName}}__ = target.{{propertyName}};
            if (__{{propertyName}}__ is ITomlSerializedObject<{{fullTypeName}}>)
            {
                if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table))
                {
                    writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
                    writer.WriteNewLine();
                    writer.BeginCurrentState(TomlValueState.Table);
                    writer.PushKey({{$"@\"{accessName}\"u8"}});
                    __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                    writer.PopKey();
                    writer.EndCurrentState();
                }
                else
                {
                    writer.PushKey({{$"@\"{accessName}\"u8"}});
                    __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                    writer.PopKey();
                }
            }
            else
            {
                writer.WriteKey({{$"@\"{accessName}\"u8"}});
                writer.WriteEqual();
                writer.BeginCurrentState(TomlValueState.ArrayOfTable);
                __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                writer.EndCurrentState();
                writer.EndKeyValue({{endKeyValue}});
            }
        }
""");
            }
            else if (kind == TomlSerializationKind.NullableStructWithTypeParameter)
            {
                if (symbol.Type is not INamedTypeSymbol namedType) break;

                var namedTypeName = namedType.ToFullFormatString();

                builder.AppendLine($$"""
        var __{{propertyName}}Formatter = options.Resolver.GetFormatter<{{namedTypeName}}>();
        if (__{{propertyName}}Formatter != null)
        {
            var __{{propertyName}}__ = target.{{propertyName}};
            if (__{{propertyName}}__ is ITomlSerializedObject<{{namedType.TypeArguments[0].ToFullFormatString()}}>)
            {
                if (options.SerializeOptions.TableStyle == TomlTableStyle.Header && (writer.State == TomlValueState.Default || writer.State == TomlValueState.Table))
                {
                    writer.WriteTableHeader({{$"@\"{accessName}\"u8"}});
                    writer.WriteNewLine();
                    writer.BeginCurrentState(TomlValueState.Table);
                    writer.PushKey({{$"@\"{accessName}\"u8"}});
                    __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                    writer.PopKey();
                    writer.EndCurrentState();
                }
                else
                {
                    writer.PushKey({{$"@\"{accessName}\"u8"}});
                    __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                    writer.PopKey();
                }
            }
            else
            {
                writer.WriteKey({{$"@\"{accessName}\"u8"}});
                writer.WriteEqual();
                writer.BeginCurrentState(TomlValueState.ArrayOfTable);
                __{{propertyName}}Formatter!.Serialize(ref writer, __{{propertyName}}__, options);
                writer.EndCurrentState();
                writer.EndKeyValue({{endKeyValue}});
            }
        }
""");
            }
            else
            {
                builder.AppendLine($$"""
        writer.WriteKey({{$"@\"{accessName}\"u8"}});
        writer.WriteEqual();
        options.Resolver.GetFormatter<{{fullTypeName}}>()!.Serialize(ref writer, target.{{propertyName}}, options);
        writer.EndKeyValue({{endKeyValue}});
""");
            }

            // Close the null check if block
            if (needsNullCheck)
            {
                builder.AppendLine($$"""
        }
""");
            }
        }
        if (!onlyTomlSerializedObject)
        {
            builder.AppendLine("        writer.EndScope();");
        }

        if (typeMeta.IsReferenceType)
        {
            builder.AppendLine($$"""

        static void ThrowIfNull(string args)
        {
            throw new CsTomlException($@"Serialization failed because the argument '{args}' is null.");
        }
""");
        }
        return builder.ToString();
    }

    private string GenerateRegisterPart(TypeMeta typeMeta)
    {
        var builder = new StringBuilder();
        foreach (var (type, kind) in typeMeta.DefinedTypes)
        {
            var fullTypeName = type.ToFullFormatString();
            switch (kind)
            {
                case TomlSerializationKind.Primitive:
                case TomlSerializationKind.PrimitiveArray:
                    continue;
                case TomlSerializationKind.Enum:
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new EnumFormatter<{{fullTypeName}}>());
        }
""");
                    break;
                case TomlSerializationKind.TomlSerializedObject:
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register<{{fullTypeName}}>();
        }
""");
                    continue;
                case TomlSerializationKind.ArrayOfITomlSerializedObject:
                    var arrayNamedType = (IArrayTypeSymbol)type;
                    var elementType = arrayNamedType.ElementType;

                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new ArrayFormatter<{{elementType.ToFullFormatString()}}>());
        }
""");
                    break;
                case TomlSerializationKind.CollectionOfITomlSerializedObject:
                    if (type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType)
                    {
                        // Nullable<T> is a special case.
                        var typeSymbol = namedTypeSymbol.ConstructUnboundGenericType();
                        if (typeSymbol.ToDisplayString() == "T?")
                        {
                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedTypeSymbol.TypeArguments[0].ToFullFormatString()}}>());
        }
""");
                            break;
                        }

                        if (FormatterTypeMetaData.TryGetGenericFormatterType(typeSymbol.ToFullFormatString(), out var typeFormatter) != GenericFormatterType.None)
                        {
                            var typeParameters = string.Join(",", namedTypeSymbol.TypeArguments.Select(x => x.ToFullFormatString()));
                            typeFormatter = typeFormatter.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{typeFormatter}}());
        }
""");
                            break;
                        }
                    }
                    else
                    {
                        if (FormatterTypeMetaData.TryGetGenericFormatterType(type, out var formatter) != GenericFormatterType.None)
                        {
                            var collectionNamedType = (INamedTypeSymbol)type;
                            var typeParameters = string.Join(",", collectionNamedType.TypeArguments.Select(x => x.ToFullFormatString()));
                            formatter = formatter!.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{formatter}}());
        }
""");
                        }
                    }

                    break;
                case TomlSerializationKind.Dictionary:
                    if (FormatterTypeMetaData.TryGetGenericFormatterType(type, out var dictFormatter) != GenericFormatterType.None)
                    {
                        var dictNamedType = (INamedTypeSymbol)type;
                        var typeParameters = string.Join(",", dictNamedType.TypeArguments.Select(x => x.ToFullFormatString()));
                        dictFormatter = dictFormatter!.Replace("TYPEPARAMETER", typeParameters);

                        builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{dictFormatter}}());
        }
""");
                    }
                    break;
                case TomlSerializationKind.NullableStructWithTypeParameter:
                    if (type is not INamedTypeSymbol namedType) break;

                    var namedTypeName = namedType.ToFullFormatString();
                    builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{namedTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedType.TypeArguments[0].ToFullFormatString()}}>());
        }
""");

                    break;
                default:
                    if (FormatterTypeMetaData.ContainsBuiltInFormatterType(type))
                        break;

                    if (type is INamedTypeSymbol namedTypeSymbol2 && namedTypeSymbol2.IsGenericType)
                    {
                        // Nullable<T> is a special case.
                        var typeSymbol = namedTypeSymbol2.ConstructUnboundGenericType();
                        if (typeSymbol.ToDisplayString() == "T?")
                        {
                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new NullableFormatter<{{namedTypeSymbol2.TypeArguments[0].ToFullFormatString()}}>());
        }
""");
                            break;
                        }

                        if (FormatterTypeMetaData.TryGetGenericFormatterType(typeSymbol.ToFullFormatString(), out var typeFormatter) != GenericFormatterType.None)
                        {
                            var typeParameters = string.Join(",", namedTypeSymbol2.TypeArguments.Select(x => x.ToFullFormatString()));
                            typeFormatter = typeFormatter.Replace("TYPEPARAMETER", typeParameters);

                            builder.AppendLine($$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{fullTypeName}}>())
        {
            TomlValueFormatterResolver.Register(new {{typeFormatter}}());
        }
""");
                            break;
                        }
                    }
                    break;
            }
        }

        if (typeMeta.IsReferenceType)
        {
            var code = $$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{typeMeta.TypeName}}>())
        {
            TomlValueFormatterResolver.Register(new TomlSerializedObjectFormatter<{{typeMeta.TypeName}}>());
        }

        // Register Formatter in advance.
{{builder}}
""";
            return code;
        }
        else
        {
            var code = $$"""
        if (!TomlValueFormatterResolver.IsRegistered<{{typeMeta.TypeName}}>())
        {
            TomlValueFormatterResolver.Register(new StructTomlSerializedObjectFormatter<{{typeMeta.TypeName}}>());
        }

        // Register Formatter in advance.
{{builder}}
""";
            return code;
        }
    }
}

internal class Comparer : IEqualityComparer<(GeneratorAttributeSyntaxContext, Compilation)>
{
    public static readonly Comparer Instance = new();

    public bool Equals((GeneratorAttributeSyntaxContext, Compilation) x, (GeneratorAttributeSyntaxContext, Compilation) y)
    {
        return x.Item1.TargetNode.Equals(y.Item1.TargetNode);
    }

    public int GetHashCode((GeneratorAttributeSyntaxContext, Compilation) obj)
    {
        return obj.Item1.TargetNode.GetHashCode();
    }
}
